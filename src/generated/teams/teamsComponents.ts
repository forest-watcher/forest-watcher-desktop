/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
import * as reactQuery from "@tanstack/react-query";
import { useTeamsContext, TeamsContext } from "./teamsContext";
import type * as Fetcher from "./teamsFetcher";
import { teamsFetch } from "./teamsFetcher";
import type * as Schemas from "./teamsSchemas";
import type * as RequestBodies from "./teamsRequestBodies";
import type * as Responses from "./teamsResponses";

export type PostTeamError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.Error;
    }
  | {
      status: 401;
      payload: Responses.Error;
    }
>;

export type PostTeamVariables = {
  body: RequestBodies.Team;
} & TeamsContext["fetcherOptions"];

export const fetchPostTeam = (variables: PostTeamVariables, signal?: AbortSignal) =>
  teamsFetch<Responses.Team, PostTeamError, RequestBodies.Team, {}, {}, {}>({
    url: "/v1/teams",
    method: "post",
    ...variables,
    signal
  });

export const usePostTeam = (
  options?: Omit<reactQuery.UseMutationOptions<Responses.Team, PostTeamError, PostTeamVariables>, "mutationFn">
) => {
  const { fetcherOptions } = useTeamsContext();
  return reactQuery.useMutation<Responses.Team, PostTeamError, PostTeamVariables>(
    (variables: PostTeamVariables) => fetchPostTeam({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetTeamPathParams = {
  /**
   * Team ObjectId
   */
  id: string;
};

export type GetTeamError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.Error;
}>;

export type GetTeamVariables = {
  pathParams: GetTeamPathParams;
} & TeamsContext["fetcherOptions"];

export const fetchGetTeam = (variables: GetTeamVariables, signal?: AbortSignal) =>
  teamsFetch<Responses.Team, GetTeamError, undefined, {}, {}, GetTeamPathParams>({
    url: "/v1/teams/{id}",
    method: "get",
    ...variables,
    signal
  });

export const useGetTeam = <TData = Responses.Team>(
  variables: GetTeamVariables,
  options?: Omit<reactQuery.UseQueryOptions<Responses.Team, GetTeamError, TData>, "queryKey" | "queryFn">
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useTeamsContext(options);
  return reactQuery.useQuery<Responses.Team, GetTeamError, TData>(
    queryKeyFn({ path: "/v1/teams/{id}", operationId: "getTeam", variables }),
    ({ signal }) => fetchGetTeam({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions
    }
  );
};

export type PatchTeamPathParams = {
  /**
   * Team ObjectId
   */
  id: string;
};

export type PatchTeamError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.Error;
}>;

export type PatchTeamVariables = {
  body: RequestBodies.Team;
  pathParams: PatchTeamPathParams;
} & TeamsContext["fetcherOptions"];

export const fetchPatchTeam = (variables: PatchTeamVariables, signal?: AbortSignal) =>
  teamsFetch<Responses.Team, PatchTeamError, RequestBodies.Team, {}, {}, PatchTeamPathParams>({
    url: "/v1/teams/{id}",
    method: "patch",
    ...variables,
    signal
  });

export const usePatchTeam = (
  options?: Omit<reactQuery.UseMutationOptions<Responses.Team, PatchTeamError, PatchTeamVariables>, "mutationFn">
) => {
  const { fetcherOptions } = useTeamsContext();
  return reactQuery.useMutation<Responses.Team, PatchTeamError, PatchTeamVariables>(
    (variables: PatchTeamVariables) => fetchPatchTeam({ ...fetcherOptions, ...variables }),
    options
  );
};

export type DeleteTeamPathParams = {
  /**
   * Team ObjectId
   */
  id: string;
};

export type DeleteTeamError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.Error;
    }
  | {
      status: 404;
      payload: Responses.Error;
    }
>;

export type DeleteTeamVariables = {
  pathParams: DeleteTeamPathParams;
} & TeamsContext["fetcherOptions"];

export const fetchDeleteTeam = (variables: DeleteTeamVariables, signal?: AbortSignal) =>
  teamsFetch<undefined, DeleteTeamError, undefined, {}, {}, DeleteTeamPathParams>({
    url: "/v1/teams/{id}",
    method: "delete",
    ...variables,
    signal
  });

export const useDeleteTeam = (
  options?: Omit<reactQuery.UseMutationOptions<undefined, DeleteTeamError, DeleteTeamVariables>, "mutationFn">
) => {
  const { fetcherOptions } = useTeamsContext();
  return reactQuery.useMutation<undefined, DeleteTeamError, DeleteTeamVariables>(
    (variables: DeleteTeamVariables) => fetchDeleteTeam({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetTeamByUserIdPathParams = {
  userId: string;
};

export type GetTeamByUserIdError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.Error;
    }
  | {
      status: 404;
      payload: Responses.Error;
    }
>;

export type GetTeamByUserIdVariables = {
  pathParams: GetTeamByUserIdPathParams;
} & TeamsContext["fetcherOptions"];

/**
 * Retrieve team by given user id
 */
export const fetchGetTeamByUserId = (variables: GetTeamByUserIdVariables, signal?: AbortSignal) =>
  teamsFetch<Responses.Team, GetTeamByUserIdError, undefined, {}, {}, GetTeamByUserIdPathParams>({
    url: "/v1/teams/user/{userId}",
    method: "get",
    ...variables,
    signal
  });

/**
 * Retrieve team by given user id
 */
export const useGetTeamByUserId = <TData = Responses.Team>(
  variables: GetTeamByUserIdVariables,
  options?: Omit<reactQuery.UseQueryOptions<Responses.Team, GetTeamByUserIdError, TData>, "queryKey" | "queryFn">
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useTeamsContext(options);
  return reactQuery.useQuery<Responses.Team, GetTeamByUserIdError, TData>(
    queryKeyFn({ path: "/v1/teams/user/{userId}", operationId: "getTeamByUserId", variables }),
    ({ signal }) => fetchGetTeamByUserId({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions
    }
  );
};

export type ConfirmUserIsWithinTeamPathParams = {
  /**
   * Valid user JWT token
   */
  token: string;
};

export type ConfirmUserIsWithinTeamError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.Error;
    }
  | {
      status: 401;
      payload: Responses.Error;
    }
>;

export type ConfirmUserIsWithinTeamResponse = {
  /**
   * @example 200
   */
  status: number;
  /**
   * @minLength 1
   * @example User confirmed
   */
  detail: string;
};

export type ConfirmUserIsWithinTeamVariables = {
  pathParams: ConfirmUserIsWithinTeamPathParams;
} & TeamsContext["fetcherOptions"];

/**
 * Confirms the user is within the team with the id given in the JWT token.
 * If not then the user is added to that team and if needed remove from an existing team.
 */
export const fetchConfirmUserIsWithinTeam = (variables: ConfirmUserIsWithinTeamVariables, signal?: AbortSignal) =>
  teamsFetch<
    ConfirmUserIsWithinTeamResponse,
    ConfirmUserIsWithinTeamError,
    undefined,
    {},
    {},
    ConfirmUserIsWithinTeamPathParams
  >({ url: "/v1/teams/confirm/{token}", method: "get", ...variables, signal });

/**
 * Confirms the user is within the team with the id given in the JWT token.
 * If not then the user is added to that team and if needed remove from an existing team.
 */
export const useConfirmUserIsWithinTeam = <TData = ConfirmUserIsWithinTeamResponse>(
  variables: ConfirmUserIsWithinTeamVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<ConfirmUserIsWithinTeamResponse, ConfirmUserIsWithinTeamError, TData>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useTeamsContext(options);
  return reactQuery.useQuery<ConfirmUserIsWithinTeamResponse, ConfirmUserIsWithinTeamError, TData>(
    queryKeyFn({ path: "/v1/teams/confirm/{token}", operationId: "confirmUserIsWithinTeam", variables }),
    ({ signal }) => fetchConfirmUserIsWithinTeam({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions
    }
  );
};

export type GetFwTeamsHealthcheckError = Fetcher.ErrorWrapper<undefined>;

export type GetFwTeamsHealthcheckVariables = TeamsContext["fetcherOptions"];

export const fetchGetFwTeamsHealthcheck = (variables: GetFwTeamsHealthcheckVariables, signal?: AbortSignal) =>
  teamsFetch<Responses.Healthcheck, GetFwTeamsHealthcheckError, undefined, {}, {}, {}>({
    url: "/v1/fw_teams/healthcheck",
    method: "get",
    ...variables,
    signal
  });

export const useGetFwTeamsHealthcheck = <TData = Responses.Healthcheck>(
  variables: GetFwTeamsHealthcheckVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Responses.Healthcheck, GetFwTeamsHealthcheckError, TData>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useTeamsContext(options);
  return reactQuery.useQuery<Responses.Healthcheck, GetFwTeamsHealthcheckError, TData>(
    queryKeyFn({ path: "/v1/fw_teams/healthcheck", operationId: "getFwTeamsHealthcheck", variables }),
    ({ signal }) => fetchGetFwTeamsHealthcheck({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions
    }
  );
};

export type PostV3TeamsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.Error;
    }
  | {
      status: 401;
      payload: Responses.Error;
    }
>;

export type PostV3TeamsVariables = {
  body: RequestBodies.TeamV3;
} & TeamsContext["fetcherOptions"];

/**
 * Create a team, the authenticated user will be created as the 'Administrator' of the team.
 */
export const fetchPostV3Teams = (variables: PostV3TeamsVariables, signal?: AbortSignal) =>
  teamsFetch<Responses.TeamV3, PostV3TeamsError, RequestBodies.TeamV3, {}, {}, {}>({
    url: "/v3/teams",
    method: "post",
    ...variables,
    signal
  });

/**
 * Create a team, the authenticated user will be created as the 'Administrator' of the team.
 */
export const usePostV3Teams = (
  options?: Omit<reactQuery.UseMutationOptions<Responses.TeamV3, PostV3TeamsError, PostV3TeamsVariables>, "mutationFn">
) => {
  const { fetcherOptions } = useTeamsContext();
  return reactQuery.useMutation<Responses.TeamV3, PostV3TeamsError, PostV3TeamsVariables>(
    (variables: PostV3TeamsVariables) => fetchPostV3Teams({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetV3TeamsTeamIdPathParams = {
  teamId: string;
};

export type GetV3TeamsTeamIdError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.Error;
    }
  | {
      status: 404;
      payload: Responses.Error;
    }
>;

export type GetV3TeamsTeamIdVariables = {
  pathParams: GetV3TeamsTeamIdPathParams;
} & TeamsContext["fetcherOptions"];

/**
 * Get a team by a team id.
 *
 * The authenticated user must be a member of the team.
 */
export const fetchGetV3TeamsTeamId = (variables: GetV3TeamsTeamIdVariables, signal?: AbortSignal) =>
  teamsFetch<Responses.TeamV3, GetV3TeamsTeamIdError, undefined, {}, {}, GetV3TeamsTeamIdPathParams>({
    url: "/v3/teams/{teamId}",
    method: "get",
    ...variables,
    signal
  });

/**
 * Get a team by a team id.
 *
 * The authenticated user must be a member of the team.
 */
export const useGetV3TeamsTeamId = <TData = Responses.TeamV3>(
  variables: GetV3TeamsTeamIdVariables,
  options?: Omit<reactQuery.UseQueryOptions<Responses.TeamV3, GetV3TeamsTeamIdError, TData>, "queryKey" | "queryFn">
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useTeamsContext(options);
  return reactQuery.useQuery<Responses.TeamV3, GetV3TeamsTeamIdError, TData>(
    queryKeyFn({ path: "/v3/teams/{teamId}", operationId: "getV3TeamsTeamId", variables }),
    ({ signal }) => fetchGetV3TeamsTeamId({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions
    }
  );
};

export type PatchV3TeamsTeamIdPathParams = {
  teamId: string;
};

export type PatchV3TeamsTeamIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.Error;
    }
  | {
      status: 401;
      payload: Responses.Error;
    }
  | {
      status: 404;
      payload: Responses.Error;
    }
>;

export type PatchV3TeamsTeamIdVariables = {
  body: RequestBodies.TeamV3;
  pathParams: PatchV3TeamsTeamIdPathParams;
} & TeamsContext["fetcherOptions"];

/**
 * Update a team, the authenticated user must be the "Administrator" or a "Manager" of the team.
 */
export const fetchPatchV3TeamsTeamId = (variables: PatchV3TeamsTeamIdVariables, signal?: AbortSignal) =>
  teamsFetch<Responses.TeamV3, PatchV3TeamsTeamIdError, RequestBodies.TeamV3, {}, {}, PatchV3TeamsTeamIdPathParams>({
    url: "/v3/teams/{teamId}",
    method: "patch",
    ...variables,
    signal
  });

/**
 * Update a team, the authenticated user must be the "Administrator" or a "Manager" of the team.
 */
export const usePatchV3TeamsTeamId = (
  options?: Omit<
    reactQuery.UseMutationOptions<Responses.TeamV3, PatchV3TeamsTeamIdError, PatchV3TeamsTeamIdVariables>,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useTeamsContext();
  return reactQuery.useMutation<Responses.TeamV3, PatchV3TeamsTeamIdError, PatchV3TeamsTeamIdVariables>(
    (variables: PatchV3TeamsTeamIdVariables) => fetchPatchV3TeamsTeamId({ ...fetcherOptions, ...variables }),
    options
  );
};

export type DeleteV3TeamsTeamIdPathParams = {
  teamId: string;
};

export type DeleteV3TeamsTeamIdError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.Error;
    }
  | {
      status: 404;
      payload: Responses.Error;
    }
>;

export type DeleteV3TeamsTeamIdVariables = {
  pathParams: DeleteV3TeamsTeamIdPathParams;
} & TeamsContext["fetcherOptions"];

/**
 * Delete a team, the authenticated user must be the "Administrator" of the team.
 *
 * When a team is delete all the members of the team will be removed from the TeamUserRelation model.
 */
export const fetchDeleteV3TeamsTeamId = (variables: DeleteV3TeamsTeamIdVariables, signal?: AbortSignal) =>
  teamsFetch<undefined, DeleteV3TeamsTeamIdError, undefined, {}, {}, DeleteV3TeamsTeamIdPathParams>({
    url: "/v3/teams/{teamId}",
    method: "delete",
    ...variables,
    signal
  });

/**
 * Delete a team, the authenticated user must be the "Administrator" of the team.
 *
 * When a team is delete all the members of the team will be removed from the TeamUserRelation model.
 */
export const useDeleteV3TeamsTeamId = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, DeleteV3TeamsTeamIdError, DeleteV3TeamsTeamIdVariables>,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useTeamsContext();
  return reactQuery.useMutation<undefined, DeleteV3TeamsTeamIdError, DeleteV3TeamsTeamIdVariables>(
    (variables: DeleteV3TeamsTeamIdVariables) => fetchDeleteV3TeamsTeamId({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetV3TeamsMyinvitesError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.Error;
}>;

export type GetV3TeamsMyinvitesResponse = {
  data: {
    id: string;
    type: string;
    attributes: {
      name: string;
      userRole: "administrator" | "manager" | "monitor" | "left";
      /**
       * @format date-time
       */
      createdAt: string;
      areas?: string[];
      members?: Schemas.TeamUserRelation[];
    };
  }[];
};

export type GetV3TeamsMyinvitesVariables = TeamsContext["fetcherOptions"];

/**
 * Get all the teams the authenticated user is invited to.
 */
export const fetchGetV3TeamsMyinvites = (variables: GetV3TeamsMyinvitesVariables, signal?: AbortSignal) =>
  teamsFetch<GetV3TeamsMyinvitesResponse, GetV3TeamsMyinvitesError, undefined, {}, {}, {}>({
    url: "/v3/teams/myinvites",
    method: "get",
    ...variables,
    signal
  });

/**
 * Get all the teams the authenticated user is invited to.
 */
export const useGetV3TeamsMyinvites = <TData = GetV3TeamsMyinvitesResponse>(
  variables: GetV3TeamsMyinvitesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetV3TeamsMyinvitesResponse, GetV3TeamsMyinvitesError, TData>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useTeamsContext(options);
  return reactQuery.useQuery<GetV3TeamsMyinvitesResponse, GetV3TeamsMyinvitesError, TData>(
    queryKeyFn({ path: "/v3/teams/myinvites", operationId: "getV3TeamsMyinvites", variables }),
    ({ signal }) => fetchGetV3TeamsMyinvites({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions
    }
  );
};

export type GetV3TeamsByUseridPathParams = {
  userId: string;
};

export type GetV3TeamsByUseridError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.Error;
}>;

export type GetV3TeamsByUseridResponse = {
  data: {
    id: string;
    type: string;
    attributes: {
      name: string;
      userRole: "administrator" | "manager" | "monitor" | "left";
      /**
       * @format date-time
       */
      createdAt: string;
      areas?: string[];
      members?: Schemas.TeamUserRelation[];
    };
  }[];
};

export type GetV3TeamsByUseridVariables = {
  pathParams: GetV3TeamsByUseridPathParams;
} & TeamsContext["fetcherOptions"];

/**
 * Get all the teams a user is a member of.
 */
export const fetchGetV3TeamsByUserid = (variables: GetV3TeamsByUseridVariables, signal?: AbortSignal) =>
  teamsFetch<GetV3TeamsByUseridResponse, GetV3TeamsByUseridError, undefined, {}, {}, GetV3TeamsByUseridPathParams>({
    url: "/v3/teams/user/{userId}",
    method: "get",
    ...variables,
    signal
  });

/**
 * Get all the teams a user is a member of.
 */
export const useGetV3TeamsByUserid = <TData = GetV3TeamsByUseridResponse>(
  variables: GetV3TeamsByUseridVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetV3TeamsByUseridResponse, GetV3TeamsByUseridError, TData>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useTeamsContext(options);
  return reactQuery.useQuery<GetV3TeamsByUseridResponse, GetV3TeamsByUseridError, TData>(
    queryKeyFn({ path: "/v3/teams/user/{userId}", operationId: "getV3TeamsByUserid", variables }),
    ({ signal }) => fetchGetV3TeamsByUserid({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions
    }
  );
};

export type GetV3TeamUsersPathParams = {
  teamId: string;
};

export type GetV3TeamUsersError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Responses.Error;
}>;

export type GetV3TeamUsersVariables = {
  pathParams: GetV3TeamUsersPathParams;
} & TeamsContext["fetcherOptions"];

/**
 * Get all memebers of a team, the authenticated user must be a member of the team.
 *
 * If the authenticated user is an "administrator" or a "manager" of the team they will be able to see each user's `status`, otherwise this key will be hidden.
 */
export const fetchGetV3TeamUsers = (variables: GetV3TeamUsersVariables, signal?: AbortSignal) =>
  teamsFetch<Responses.TeamUserRelations, GetV3TeamUsersError, undefined, {}, {}, GetV3TeamUsersPathParams>({
    url: "/v3/teams/{teamId}/users",
    method: "get",
    ...variables,
    signal
  });

/**
 * Get all memebers of a team, the authenticated user must be a member of the team.
 *
 * If the authenticated user is an "administrator" or a "manager" of the team they will be able to see each user's `status`, otherwise this key will be hidden.
 */
export const useGetV3TeamUsers = <TData = Responses.TeamUserRelations>(
  variables: GetV3TeamUsersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Responses.TeamUserRelations, GetV3TeamUsersError, TData>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } = useTeamsContext(options);
  return reactQuery.useQuery<Responses.TeamUserRelations, GetV3TeamUsersError, TData>(
    queryKeyFn({ path: "/v3/teams/{teamId}/users", operationId: "getV3TeamUsers", variables }),
    ({ signal }) => fetchGetV3TeamUsers({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions
    }
  );
};

export type PostV3TeamsUsersPathParams = {
  teamId: string;
};

export type PostV3TeamsUsersError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.Error;
    }
  | {
      status: 401;
      payload: Responses.Error;
    }
  | {
      status: 404;
      payload: Responses.Error;
    }
>;

export type PostV3TeamsUsersRequestBody = {
  users?: {
    email?: string;
    role?: "manager" | "monitor";
  }[];
};

export type PostV3TeamsUsersVariables = {
  body?: PostV3TeamsUsersRequestBody;
  pathParams: PostV3TeamsUsersPathParams;
} & TeamsContext["fetcherOptions"];

/**
 * Add multiple members to a team, when the user is added an invite will be sent to their email. Their `status` will be set to `invited`.
 *
 * The authenticated user has to be either the "administrator" or a "manager" of the team.
 */
export const fetchPostV3TeamsUsers = (variables: PostV3TeamsUsersVariables, signal?: AbortSignal) =>
  teamsFetch<
    Responses.TeamUserRelations,
    PostV3TeamsUsersError,
    PostV3TeamsUsersRequestBody,
    {},
    {},
    PostV3TeamsUsersPathParams
  >({ url: "/v3/teams/{teamId}/users", method: "post", ...variables, signal });

/**
 * Add multiple members to a team, when the user is added an invite will be sent to their email. Their `status` will be set to `invited`.
 *
 * The authenticated user has to be either the "administrator" or a "manager" of the team.
 */
export const usePostV3TeamsUsers = (
  options?: Omit<
    reactQuery.UseMutationOptions<Responses.TeamUserRelations, PostV3TeamsUsersError, PostV3TeamsUsersVariables>,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useTeamsContext();
  return reactQuery.useMutation<Responses.TeamUserRelations, PostV3TeamsUsersError, PostV3TeamsUsersVariables>(
    (variables: PostV3TeamsUsersVariables) => fetchPostV3TeamsUsers({ ...fetcherOptions, ...variables }),
    options
  );
};

export type PatchV3TeamsTeamIdUsersTeamUserIdPathParams = {
  teamId: string;
  teamUserId: string;
};

export type PatchV3TeamsTeamIdUsersTeamUserIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.Error;
    }
  | {
      status: 401;
      payload: Responses.Error;
    }
  | {
      status: 404;
      payload: Responses.Error;
    }
>;

export type PatchV3TeamsTeamIdUsersTeamUserIdRequestBody = {
  role?: "manager" | "monitor";
};

export type PatchV3TeamsTeamIdUsersTeamUserIdVariables = {
  body?: PatchV3TeamsTeamIdUsersTeamUserIdRequestBody;
  pathParams: PatchV3TeamsTeamIdUsersTeamUserIdPathParams;
} & TeamsContext["fetcherOptions"];

/**
 * Update a team member's role.
 *
 * Cannot change a member's role to "administrator"\
 * An administrator's role can't be changed
 *
 * The authenticated user has to be either the "administrator" or a "manager" of the team.
 */
export const fetchPatchV3TeamsTeamIdUsersTeamUserId = (
  variables: PatchV3TeamsTeamIdUsersTeamUserIdVariables,
  signal?: AbortSignal
) =>
  teamsFetch<
    Responses.TeamUserRelation,
    PatchV3TeamsTeamIdUsersTeamUserIdError,
    PatchV3TeamsTeamIdUsersTeamUserIdRequestBody,
    {},
    {},
    PatchV3TeamsTeamIdUsersTeamUserIdPathParams
  >({ url: "/v3/teams/{teamId}/users/{teamUserId}", method: "patch", ...variables, signal });

/**
 * Update a team member's role.
 *
 * Cannot change a member's role to "administrator"\
 * An administrator's role can't be changed
 *
 * The authenticated user has to be either the "administrator" or a "manager" of the team.
 */
export const usePatchV3TeamsTeamIdUsersTeamUserId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Responses.TeamUserRelation,
      PatchV3TeamsTeamIdUsersTeamUserIdError,
      PatchV3TeamsTeamIdUsersTeamUserIdVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useTeamsContext();
  return reactQuery.useMutation<
    Responses.TeamUserRelation,
    PatchV3TeamsTeamIdUsersTeamUserIdError,
    PatchV3TeamsTeamIdUsersTeamUserIdVariables
  >(
    (variables: PatchV3TeamsTeamIdUsersTeamUserIdVariables) =>
      fetchPatchV3TeamsTeamIdUsersTeamUserId({ ...fetcherOptions, ...variables }),
    options
  );
};

export type DeleteV3TeamsTeamIdUsersTeamUserIdPathParams = {
  teamId: string;
  teamUserId: string;
};

export type DeleteV3TeamsTeamIdUsersTeamUserIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.Error;
    }
  | {
      status: 401;
      payload: Responses.Error;
    }
>;

export type DeleteV3TeamsTeamIdUsersTeamUserIdVariables = {
  pathParams: DeleteV3TeamsTeamIdUsersTeamUserIdPathParams;
} & TeamsContext["fetcherOptions"];

/**
 * Delete a team member.
 *
 * Cannot delete the "administrator"\
 *
 * The authenticated user has to be either the "administrator" or a "manager" of the team or the user that is being deleted (only used in the case of account deletion). In all other cases, leave the team by `/v3/teams/{teamId}/users/{userId}/leave`
 */
export const fetchDeleteV3TeamsTeamIdUsersTeamUserId = (
  variables: DeleteV3TeamsTeamIdUsersTeamUserIdVariables,
  signal?: AbortSignal
) =>
  teamsFetch<
    Responses.TeamUserRelation,
    DeleteV3TeamsTeamIdUsersTeamUserIdError,
    undefined,
    {},
    {},
    DeleteV3TeamsTeamIdUsersTeamUserIdPathParams
  >({ url: "/v3/teams/{teamId}/users/{teamUserId}", method: "delete", ...variables, signal });

/**
 * Delete a team member.
 *
 * Cannot delete the "administrator"\
 *
 * The authenticated user has to be either the "administrator" or a "manager" of the team or the user that is being deleted (only used in the case of account deletion). In all other cases, leave the team by `/v3/teams/{teamId}/users/{userId}/leave`
 */
export const useDeleteV3TeamsTeamIdUsersTeamUserId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Responses.TeamUserRelation,
      DeleteV3TeamsTeamIdUsersTeamUserIdError,
      DeleteV3TeamsTeamIdUsersTeamUserIdVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useTeamsContext();
  return reactQuery.useMutation<
    Responses.TeamUserRelation,
    DeleteV3TeamsTeamIdUsersTeamUserIdError,
    DeleteV3TeamsTeamIdUsersTeamUserIdVariables
  >(
    (variables: DeleteV3TeamsTeamIdUsersTeamUserIdVariables) =>
      fetchDeleteV3TeamsTeamIdUsersTeamUserId({ ...fetcherOptions, ...variables }),
    options
  );
};

export type PatchV3TeamsTeamIdUsersReassignAdminUserIdPathParams = {
  teamId: string;
  userId: string;
};

export type PatchV3TeamsTeamIdUsersReassignAdminUserIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Responses.Error;
    }
  | {
      status: 401;
      payload: Responses.Error;
    }
  | {
      status: 404;
      payload: Responses.Error;
    }
>;

export type PatchV3TeamsTeamIdUsersReassignAdminUserIdVariables = {
  pathParams: PatchV3TeamsTeamIdUsersReassignAdminUserIdPathParams;
} & TeamsContext["fetcherOptions"];

/**
 * Reassign the administrator role to the user with user id {userId} with this user's team relation returned as a response. The current administrator is demoted to a manager.
 *
 * Only the administrator can do this (401 thrown if anyone but administrator hits the endpoint).
 *
 * 400 thrown if administrator tries to update themselves.
 */
export const fetchPatchV3TeamsTeamIdUsersReassignAdminUserId = (
  variables: PatchV3TeamsTeamIdUsersReassignAdminUserIdVariables,
  signal?: AbortSignal
) =>
  teamsFetch<
    Responses.TeamUserRelation,
    PatchV3TeamsTeamIdUsersReassignAdminUserIdError,
    undefined,
    {},
    {},
    PatchV3TeamsTeamIdUsersReassignAdminUserIdPathParams
  >({ url: "/v3/teams/{teamId}/users/reassignAdmin/{userId}", method: "patch", ...variables, signal });

/**
 * Reassign the administrator role to the user with user id {userId} with this user's team relation returned as a response. The current administrator is demoted to a manager.
 *
 * Only the administrator can do this (401 thrown if anyone but administrator hits the endpoint).
 *
 * 400 thrown if administrator tries to update themselves.
 */
export const usePatchV3TeamsTeamIdUsersReassignAdminUserId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Responses.TeamUserRelation,
      PatchV3TeamsTeamIdUsersReassignAdminUserIdError,
      PatchV3TeamsTeamIdUsersReassignAdminUserIdVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useTeamsContext();
  return reactQuery.useMutation<
    Responses.TeamUserRelation,
    PatchV3TeamsTeamIdUsersReassignAdminUserIdError,
    PatchV3TeamsTeamIdUsersReassignAdminUserIdVariables
  >(
    (variables: PatchV3TeamsTeamIdUsersReassignAdminUserIdVariables) =>
      fetchPatchV3TeamsTeamIdUsersReassignAdminUserId({ ...fetcherOptions, ...variables }),
    options
  );
};

export type V3GetTeamsTeamIdUsersUserIdAcceptPathParams = {
  teamId: string;
  userId: string;
};

export type V3GetTeamsTeamIdUsersUserIdAcceptError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.Error;
    }
  | {
      status: 404;
      payload: Responses.Error;
    }
>;

export type V3GetTeamsTeamIdUsersUserIdAcceptVariables = {
  pathParams: V3GetTeamsTeamIdUsersUserIdAcceptPathParams;
} & TeamsContext["fetcherOptions"];

/**
 * Allows user to accept their invitation to a team.
 *
 * The authenticated user's id must match the param's id.
 *
 * The memeber's `status` will be updated to `confirmed`.
 */
export const fetchV3GetTeamsTeamIdUsersUserIdAccept = (
  variables: V3GetTeamsTeamIdUsersUserIdAcceptVariables,
  signal?: AbortSignal
) =>
  teamsFetch<
    Responses.TeamUserRelation,
    V3GetTeamsTeamIdUsersUserIdAcceptError,
    undefined,
    {},
    {},
    V3GetTeamsTeamIdUsersUserIdAcceptPathParams
  >({ url: "/v3/teams/{teamId}/users/{userId}/accept", method: "patch", ...variables, signal });

/**
 * Allows user to accept their invitation to a team.
 *
 * The authenticated user's id must match the param's id.
 *
 * The memeber's `status` will be updated to `confirmed`.
 */
export const useV3GetTeamsTeamIdUsersUserIdAccept = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Responses.TeamUserRelation,
      V3GetTeamsTeamIdUsersUserIdAcceptError,
      V3GetTeamsTeamIdUsersUserIdAcceptVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useTeamsContext();
  return reactQuery.useMutation<
    Responses.TeamUserRelation,
    V3GetTeamsTeamIdUsersUserIdAcceptError,
    V3GetTeamsTeamIdUsersUserIdAcceptVariables
  >(
    (variables: V3GetTeamsTeamIdUsersUserIdAcceptVariables) =>
      fetchV3GetTeamsTeamIdUsersUserIdAccept({ ...fetcherOptions, ...variables }),
    options
  );
};

export type V3GetTeamsTeamIdUsersUserIdDeclinePathParams = {
  teamId: string;
  userId: string;
};

export type V3GetTeamsTeamIdUsersUserIdDeclineError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.Error;
    }
  | {
      status: 404;
      payload: Responses.Error;
    }
>;

export type V3GetTeamsTeamIdUsersUserIdDeclineVariables = {
  pathParams: V3GetTeamsTeamIdUsersUserIdDeclinePathParams;
} & TeamsContext["fetcherOptions"];

/**
 * Allows user to decline their invitation to a team.
 *
 * The authenticated user's id must match the param's `userId`.
 *
 * The memeber's `status` will be updated to `declined`.
 */
export const fetchV3GetTeamsTeamIdUsersUserIdDecline = (
  variables: V3GetTeamsTeamIdUsersUserIdDeclineVariables,
  signal?: AbortSignal
) =>
  teamsFetch<
    Responses.TeamUserRelation,
    V3GetTeamsTeamIdUsersUserIdDeclineError,
    undefined,
    {},
    {},
    V3GetTeamsTeamIdUsersUserIdDeclinePathParams
  >({ url: "/v3/teams/{teamId}/users/{userId}/decline", method: "patch", ...variables, signal });

/**
 * Allows user to decline their invitation to a team.
 *
 * The authenticated user's id must match the param's `userId`.
 *
 * The memeber's `status` will be updated to `declined`.
 */
export const useV3GetTeamsTeamIdUsersUserIdDecline = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Responses.TeamUserRelation,
      V3GetTeamsTeamIdUsersUserIdDeclineError,
      V3GetTeamsTeamIdUsersUserIdDeclineVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useTeamsContext();
  return reactQuery.useMutation<
    Responses.TeamUserRelation,
    V3GetTeamsTeamIdUsersUserIdDeclineError,
    V3GetTeamsTeamIdUsersUserIdDeclineVariables
  >(
    (variables: V3GetTeamsTeamIdUsersUserIdDeclineVariables) =>
      fetchV3GetTeamsTeamIdUsersUserIdDecline({ ...fetcherOptions, ...variables }),
    options
  );
};

export type V3GetTeamsTeamIdUsersUserIdLeavePathParams = {
  teamId: string;
  userId: string;
};

export type V3GetTeamsTeamIdUsersUserIdLeaveError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Responses.Error;
    }
  | {
      status: 404;
      payload: Responses.Error;
    }
>;

export type V3GetTeamsTeamIdUsersUserIdLeaveVariables = {
  pathParams: V3GetTeamsTeamIdUsersUserIdLeavePathParams;
} & TeamsContext["fetcherOptions"];

/**
 * Allows user to leave a team.
 *
 * The authenticated user's id must match the param's `userId`.
 *
 * If the authenticated user is the "administrator" then they can't leave the team.
 *
 * The memeber's `role` will be updated to `left`.
 */
export const fetchV3GetTeamsTeamIdUsersUserIdLeave = (
  variables: V3GetTeamsTeamIdUsersUserIdLeaveVariables,
  signal?: AbortSignal
) =>
  teamsFetch<
    Responses.TeamUserRelation,
    V3GetTeamsTeamIdUsersUserIdLeaveError,
    undefined,
    {},
    {},
    V3GetTeamsTeamIdUsersUserIdLeavePathParams
  >({ url: "/v3/teams/{teamId}/users/{userId}/leave", method: "patch", ...variables, signal });

/**
 * Allows user to leave a team.
 *
 * The authenticated user's id must match the param's `userId`.
 *
 * If the authenticated user is the "administrator" then they can't leave the team.
 *
 * The memeber's `role` will be updated to `left`.
 */
export const useV3GetTeamsTeamIdUsersUserIdLeave = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Responses.TeamUserRelation,
      V3GetTeamsTeamIdUsersUserIdLeaveError,
      V3GetTeamsTeamIdUsersUserIdLeaveVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useTeamsContext();
  return reactQuery.useMutation<
    Responses.TeamUserRelation,
    V3GetTeamsTeamIdUsersUserIdLeaveError,
    V3GetTeamsTeamIdUsersUserIdLeaveVariables
  >(
    (variables: V3GetTeamsTeamIdUsersUserIdLeaveVariables) =>
      fetchV3GetTeamsTeamIdUsersUserIdLeave({ ...fetcherOptions, ...variables }),
    options
  );
};

export type QueryOperation =
  | {
      path: "/v1/teams/{id}";
      operationId: "getTeam";
      variables: GetTeamVariables;
    }
  | {
      path: "/v1/teams/user/{userId}";
      operationId: "getTeamByUserId";
      variables: GetTeamByUserIdVariables;
    }
  | {
      path: "/v1/teams/confirm/{token}";
      operationId: "confirmUserIsWithinTeam";
      variables: ConfirmUserIsWithinTeamVariables;
    }
  | {
      path: "/v1/fw_teams/healthcheck";
      operationId: "getFwTeamsHealthcheck";
      variables: GetFwTeamsHealthcheckVariables;
    }
  | {
      path: "/v3/teams/{teamId}";
      operationId: "getV3TeamsTeamId";
      variables: GetV3TeamsTeamIdVariables;
    }
  | {
      path: "/v3/teams/myinvites";
      operationId: "getV3TeamsMyinvites";
      variables: GetV3TeamsMyinvitesVariables;
    }
  | {
      path: "/v3/teams/user/{userId}";
      operationId: "getV3TeamsByUserid";
      variables: GetV3TeamsByUseridVariables;
    }
  | {
      path: "/v3/teams/{teamId}/users";
      operationId: "getV3TeamUsers";
      variables: GetV3TeamUsersVariables;
    };
